<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>室内动态灯光系统测试</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }

    #container {
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 400px;
    }

    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    .controls button {
      margin: 5px;
      padding: 5px 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #45a049;
    }

    .controls button.danger {
      background: #f44336;
    }

    .controls button.danger:hover {
      background: #da190b;
    }

    .status {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    .building-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    .building-controls input {
      margin: 5px;
      padding: 3px;
      width: 60px;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div class="info">
    <h3>室内动态灯光系统测试</h3>
    <p>当前状态: <span id="currentStatus">初始化中...</span></p>
    <p>灯光系统: <span id="lightsStatus">未创建</span></p>
    <p>HDR天空: <span id="hdrStatus">未设置</span></p>
    <p>建筑模型: <span id="buildingStatus">未加载</span></p>
    <p>灯光数量: <span id="lightCount">0</span></p>
  </div>
  <div class="controls">
    <h4>场景控制</h4>
    <button onclick="simulateEnter()">模拟进入室内</button>
    <button onclick="simulateLeave()" class="danger">模拟离开室内</button>
    <button onclick="createLights()">创建灯光</button>
    <button onclick="createAndSetupLights()">创建并设置灯光</button>
    <button onclick="removeLights()" class="danger">移除灯光</button>
    <button onclick="adjustLights()">调整灯光位置</button>
    <button onclick="toggleLightHelpers()">切换灯光辅助器</button>
    <button onclick="checkStatus()">检查状态</button>
  </div>
  <div class="building-controls">
    <h4>建筑控制</h4>
    <div>
      <label>宽度: <input type="number" id="buildingWidth" value="20" min="5" max="100"></label>
    </div>
    <div>
      <label>高度: <input type="number" id="buildingHeight" value="15" min="5" max="50"></label>
    </div>
    <div>
      <label>深度: <input type="number" id="buildingDepth" value="25" min="5" max="100"></label>
    </div>
    <button onclick="updateBuilding()">更新建筑</button>
  </div>
  <div class="status">
    <p>日志: <span id="log">-</span></p>
  </div>

  <script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';
    import { RGBELoader } from './node_modules/three/examples/jsm/loaders/RGBELoader.js';
    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';

    // 全局变量
    let scene, camera, renderer, controls;
    let lights = {};
    let building = null;
    let lightHelpers = [];
    let showHelpers = false;
    let hdrLoaded = false;

    // 初始化场景
    function init () {
      // 创建场景
      scene = new THREE.Scene();

      // 创建相机
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(30, 30, 30);

      // 创建渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('container').appendChild(renderer.domElement);

      // 创建控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // 创建默认建筑
      createBuilding(20, 15, 25);

      console.log("场景初始化完成");
      updateStatus("场景初始化完成");
    }

    // 创建建筑模型
    function createBuilding (width, height, depth) {
      // 移除现有建筑
      if (building) {
        scene.remove(building);
      }

      // 创建建筑组
      building = new THREE.Group();
      building.name = "building";

      // 创建建筑主体
      const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
      const buildingMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xcccccc,
        metalness: 0.1,
        roughness: 0.8,
        transparent: true,
        opacity: 0.9
      });
      const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
      buildingMesh.castShadow = true;
      buildingMesh.receiveShadow = true;
      building.add(buildingMesh);

      // 创建地面
      const groundGeometry = new THREE.PlaneGeometry(width * 2, depth * 2);
      const groundMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x888888,
        metalness: 0.0,
        roughness: 0.9
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -height / 2 - 0.1;
      ground.receiveShadow = true;
      building.add(ground);

      scene.add(building);

      console.log(`建筑创建完成: ${width}x${height}x${depth}`);
      updateStatus(`建筑创建完成: ${width}x${height}x${depth}`);
      updateBuildingStatus();
    }

    // 创建灯光系统
    function createLights () {
      console.log("创建室内灯光系统...");
      updateStatus("创建室内灯光系统...");

      // 创建环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      lights.ambient = ambientLight;
      scene.add(ambientLight);

      // 创建主方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 1000;
      directionalLight.shadow.camera.right = 1000;
      directionalLight.shadow.camera.left = -1000;
      directionalLight.shadow.camera.top = 600;
      directionalLight.shadow.camera.bottom = -600;
      directionalLight.shadow.mapSize.width = Math.pow(2, 11);
      directionalLight.shadow.mapSize.height = Math.pow(2, 11);
      directionalLight.shadow.blurSamples = 8;
      directionalLight.shadow.radius = 1.15;
      directionalLight.shadow.bias = -0.0015;
      directionalLight.castShadow = true;

      lights.main = directionalLight;
      scene.add(directionalLight);

      // 创建辅助方向光
      const auxiliaryLight = new THREE.DirectionalLight(0xffffff, 0.4);
      lights.auxiliary = auxiliaryLight;
      scene.add(auxiliaryLight);

      console.log("室内灯光系统创建完成");
      updateStatus("室内灯光系统创建完成");
      updateLightsStatus();
    }

    // 根据建筑包围盒创建和设置灯光
    function createAndSetupLights () {
      if (!building) {
        console.warn("建筑对象未创建，无法设置灯光");
        return;
      }

      console.log("根据建筑包围盒创建和设置灯光...");
      updateStatus("根据建筑包围盒创建和设置灯光...");

      // 获取建筑包围盒
      const box = new THREE.Box3().setFromObject(building);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      console.log("建筑包围盒信息:", {
        center: center,
        size: size,
      });

      // 计算建筑尺寸
      const buildingWidth = size.x;
      const buildingHeight = size.y;
      const buildingDepth = size.z;
      const maxDimension = Math.max(buildingWidth, buildingHeight, buildingDepth);

      // 创建环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      lights.ambient = ambientLight;
      scene.add(ambientLight);

      // 创建主方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 1000;
      directionalLight.shadow.camera.right = 1000;
      directionalLight.shadow.camera.left = -1000;
      directionalLight.shadow.camera.top = 600;
      directionalLight.shadow.camera.bottom = -600;
      directionalLight.shadow.mapSize.width = Math.pow(2, 11);
      directionalLight.shadow.mapSize.height = Math.pow(2, 11);
      directionalLight.shadow.blurSamples = 8;
      directionalLight.shadow.radius = 1.15;
      directionalLight.shadow.bias = -0.0015;
      directionalLight.castShadow = true;

      lights.main = directionalLight;
      scene.add(directionalLight);

      // 创建辅助方向光
      const auxiliaryLight = new THREE.DirectionalLight(0xffffff, 0.4);
      lights.auxiliary = auxiliaryLight;
      scene.add(auxiliaryLight);

      // 根据建筑尺寸调整灯光位置
      const mainLightHeight = center.y + buildingHeight * 0.8;
      const mainLightOffset = maxDimension * 0.8;

      // 主方向光位置：建筑中心上方，稍微偏移
      lights.main.position.set(
        center.x - mainLightOffset * 0.5,
        mainLightHeight,
        center.z - mainLightOffset * 0.8
      );

      // 调整主方向光的目标点（建筑中心）
      lights.main.target.position.copy(center);
      lights.main.target.updateMatrixWorld();

      // 调整主方向光的阴影相机参数
      const shadowSize = maxDimension * 2;
      lights.main.shadow.camera.left = -shadowSize;
      lights.main.shadow.camera.right = shadowSize;
      lights.main.shadow.camera.top = shadowSize;
      lights.main.shadow.camera.bottom = -shadowSize;
      lights.main.shadow.camera.near = 0.1;
      lights.main.shadow.camera.far = maxDimension * 4;
      lights.main.shadow.camera.updateProjectionMatrix();

      // 调整辅助方向光位置
      const auxiliaryLightDistance = maxDimension * 1.2;
      lights.auxiliary.position.set(
        center.x + auxiliaryLightDistance * 0.6,
        center.y + buildingHeight * 0.6,
        center.z + auxiliaryLightDistance * 0.4
      );

      // 调整辅助方向光的目标点
      lights.auxiliary.target.position.copy(center);
      lights.auxiliary.target.updateMatrixWorld();

      // 根据建筑尺寸调整灯光强度
      const buildingVolume = buildingWidth * buildingHeight * buildingDepth;
      const volumeFactor = Math.min(buildingVolume / 1000000, 2.0);

      lights.main.intensity = 1.4 * volumeFactor;
      lights.auxiliary.intensity = 0.4 * volumeFactor;
      lights.ambient.intensity = 1.5 * Math.min(volumeFactor, 1.5);

      console.log("灯光创建和位置设置完成:", {
        mainLight: lights.main.position,
        auxiliaryLight: lights.auxiliary.position,
        mainIntensity: lights.main.intensity,
        auxiliaryIntensity: lights.auxiliary.intensity,
        ambientIntensity: lights.ambient.intensity,
      });

      updateStatus("灯光创建和位置设置完成");
      updateLightsStatus();
    }

    // 移除灯光系统
    function removeLights () {
      console.log("移除室内灯光系统...");
      updateStatus("移除室内灯光系统...");

      // 移除灯光辅助器
      removeLightHelpers();

      // 移除灯光
      if (lights.ambient) {
        scene.remove(lights.ambient);
        lights.ambient.dispose();
        lights.ambient = null;
      }
      if (lights.main) {
        scene.remove(lights.main);
        lights.main.dispose();
        lights.main = null;
      }
      if (lights.auxiliary) {
        scene.remove(lights.auxiliary);
        lights.auxiliary.dispose();
        lights.auxiliary = null;
      }

      lights = {};
      console.log("室内灯光系统移除完成");
      updateStatus("室内灯光系统移除完成");
      updateLightsStatus();
    }

    // 根据建筑包围盒调整灯光位置
    function adjustLightsToBuilding () {
      if (!building || !lights.main || !lights.auxiliary) {
        console.warn("建筑或灯光未创建，无法调整灯光位置");
        return;
      }

      console.log("根据建筑包围盒调整灯光位置...");
      updateStatus("调整灯光位置...");

      // 获取建筑包围盒
      const box = new THREE.Box3().setFromObject(building);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const min = box.min;
      const max = box.max;

      console.log("建筑包围盒信息:", {
        center: center,
        size: size,
        min: min,
        max: max,
      });

      // 计算建筑尺寸
      const buildingWidth = size.x;
      const buildingHeight = size.y;
      const buildingDepth = size.z;
      const maxDimension = Math.max(buildingWidth, buildingHeight, buildingDepth);

      // 调整主方向光位置
      const mainLightDistance = maxDimension * 1.5;
      const mainLightHeight = center.y + buildingHeight * 0.8;
      const mainLightOffset = maxDimension * 0.8;

      // 主方向光位置：建筑中心上方，稍微偏移
      lights.main.position.set(
        center.x - mainLightOffset * 0.5,
        mainLightHeight,
        center.z - mainLightOffset * 0.8
      );

      // 调整主方向光的目标点（建筑中心）
      lights.main.target.position.copy(center);
      lights.main.target.updateMatrixWorld();

      // 调整主方向光的阴影相机参数
      const shadowSize = maxDimension * 2;
      lights.main.shadow.camera.left = -shadowSize;
      lights.main.shadow.camera.right = shadowSize;
      lights.main.shadow.camera.top = shadowSize;
      lights.main.shadow.camera.bottom = -shadowSize;
      lights.main.shadow.camera.near = 0.1;
      lights.main.shadow.camera.far = maxDimension * 4;
      lights.main.shadow.camera.updateProjectionMatrix();

      // 调整辅助方向光位置
      const auxiliaryLightDistance = maxDimension * 1.2;
      lights.auxiliary.position.set(
        center.x + auxiliaryLightDistance * 0.6,
        center.y + buildingHeight * 0.6,
        center.z + auxiliaryLightDistance * 0.4
      );

      // 调整辅助方向光的目标点
      lights.auxiliary.target.position.copy(center);
      lights.auxiliary.target.updateMatrixWorld();

      // 根据建筑尺寸调整灯光强度
      const buildingVolume = buildingWidth * buildingHeight * buildingDepth;
      const volumeFactor = Math.min(buildingVolume / 1000000, 2.0);

      lights.main.intensity = 1.4 * volumeFactor;
      lights.auxiliary.intensity = 0.4 * volumeFactor;
      lights.ambient.intensity = 1.5 * Math.min(volumeFactor, 1.5);

      console.log("灯光位置调整完成");
      updateStatus("灯光位置调整完成");

      // 更新灯光辅助器
      if (showHelpers) {
        addLightHelpers();
      }
    }

    // 添加灯光辅助器
    function addLightHelpers () {
      removeLightHelpers();

      if (lights.main) {
        const mainHelper = new THREE.DirectionalLightHelper(lights.main, 5);
        scene.add(mainHelper);
        lightHelpers.push(mainHelper);

        const shadowHelper = new THREE.CameraHelper(lights.main.shadow.camera);
        scene.add(shadowHelper);
        lightHelpers.push(shadowHelper);
      }

      if (lights.auxiliary) {
        const auxiliaryHelper = new THREE.DirectionalLightHelper(lights.auxiliary, 3);
        scene.add(auxiliaryHelper);
        lightHelpers.push(auxiliaryHelper);
      }

      console.log("灯光辅助器已添加");
    }

    // 移除灯光辅助器
    function removeLightHelpers () {
      lightHelpers.forEach(helper => {
        scene.remove(helper);
        helper.dispose();
      });
      lightHelpers = [];
    }

    // 切换灯光辅助器
    function toggleLightHelpers () {
      showHelpers = !showHelpers;
      if (showHelpers) {
        addLightHelpers();
        updateStatus("灯光辅助器已显示");
      } else {
        removeLightHelpers();
        updateStatus("灯光辅助器已隐藏");
      }
    }

    // 设置HDR天空
    function setIndoorHDRSky () {
      console.log("开始加载室内HDR天空贴图...");
      updateStatus("开始加载HDR天空...");

      const loader = new RGBELoader();
      loader.setDataType(THREE.FloatType);

      loader.load(
        './public/bg.hdr',
        (texture) => {
          console.log("HDR加载成功:", texture);

          texture.mapping = THREE.EquirectangularReflectionMapping;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.exposure = 1.5;

          scene.background = texture;

          const envTexture = texture.clone();
          envTexture.intensity = 1.2;
          scene.environment = envTexture;

          hdrLoaded = true;
          console.log("HDR天空贴图设置完成");
          updateStatus("HDR天空设置完成");
          updateHDRStatus();
        },
        (progress) => {
          if (progress.lengthComputable) {
            const percent = (progress.loaded / progress.total) * 100;
            updateStatus(`HDR加载进度: ${percent.toFixed(1)}%`);
          }
        },
        (error) => {
          console.error("HDR加载失败:", error);
          updateStatus("HDR加载失败，使用默认天空");
          setDefaultSky();
        }
      );
    }

    // 设置默认天空
    function setDefaultSky () {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 512;
      const context = canvas.getContext('2d');

      const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#FFD700');
      gradient.addColorStop(0.3, '#FFA500');
      gradient.addColorStop(0.7, '#FF8C00');
      gradient.addColorStop(1, '#FF4500');

      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);

      const texture = new THREE.CanvasTexture(canvas);
      texture.mapping = THREE.EquirectangularReflectionMapping;
      texture.colorSpace = THREE.SRGBColorSpace;

      scene.background = texture;

      const envTexture = texture.clone();
      envTexture.intensity = 0.8;
      scene.environment = envTexture;

      hdrLoaded = true;
      console.log("默认天空贴图设置完成");
      updateStatus("默认天空设置完成");
      updateHDRStatus();
    }

    // 清理HDR
    function clearHDR () {
      console.log("清理HDR环境贴图...");

      if (scene.background) {
        scene.background.dispose();
        scene.background = null;
      }

      if (scene.environment) {
        scene.environment.dispose();
        scene.environment = null;
      }

      hdrLoaded = false;
      console.log("HDR环境贴图清理完成");
      updateStatus("HDR环境贴图已清理");
      updateHDRStatus();
    }

    // 更新状态显示
    function updateStatus (message) {
      document.getElementById('log').textContent = message;
      console.log(message);
    }

    // 更新灯光状态
    function updateLightsStatus () {
      const lightCount = Object.keys(lights).length;
      document.getElementById('lightsStatus').textContent = lightCount > 0 ? `已创建 (${lightCount}个)` : "未创建";
      document.getElementById('lightCount').textContent = lightCount;
    }

    // 更新HDR状态
    function updateHDRStatus () {
      document.getElementById('hdrStatus').textContent = hdrLoaded ? "已设置" : "未设置";
    }

    // 更新建筑状态
    function updateBuildingStatus () {
      document.getElementById('buildingStatus').textContent = building ? "已加载" : "未加载";
    }

    // 检查状态
    function checkStatus () {
      updateLightsStatus();
      updateHDRStatus();
      updateBuildingStatus();
      updateStatus("状态检查完成");
    }

    // 模拟进入室内
    function simulateEnter () {
      console.log("模拟进入室内...");
      updateStatus("模拟进入室内...");
      setIndoorHDRSky();
      createAndSetupLights();
    }

    // 模拟离开室内
    function simulateLeave () {
      console.log("模拟离开室内...");
      updateStatus("模拟离开室内...");
      clearHDR();
      removeLights();
    }

    // 更新建筑
    function updateBuilding () {
      const width = parseFloat(document.getElementById('buildingWidth').value);
      const height = parseFloat(document.getElementById('buildingHeight').value);
      const depth = parseFloat(document.getElementById('buildingDepth').value);

      createBuilding(width, height, depth);

      if (Object.keys(lights).length > 0) {
        adjustLightsToBuilding();
      }
    }

    // 暴露全局函数
    window.simulateEnter = simulateEnter;
    window.simulateLeave = simulateLeave;
    window.createLights = createLights;
    window.createAndSetupLights = createAndSetupLights;
    window.removeLights = removeLights;
    window.adjustLights = adjustLightsToBuilding;
    window.toggleLightHelpers = toggleLightHelpers;
    window.checkStatus = checkStatus;
    window.updateBuilding = updateBuilding;

    // 动画循环
    function animate () {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // 窗口大小调整
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 初始化
    init();
    animate();

    // 初始状态检查
    setTimeout(() => {
      checkStatus();
    }, 1000);
  </script>
</body>

</html>
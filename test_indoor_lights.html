<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>室内灯光调整测试</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }

    #container {
      width: 100vw;
      height: 100vh;
    }

    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
    }

    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    .controls button {
      margin: 5px;
      padding: 5px 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #45a049;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div class="info">
    <h3>室内灯光调整测试</h3>
    <p>当前建筑: <span id="buildingInfo">加载中...</span></p>
    <p>主灯光位置: <span id="mainLightPos">-</span></p>
    <p>辅助灯光位置: <span id="auxLightPos">-</span></p>
    <p>建筑包围盒: <span id="buildingBox">-</span></p>
  </div>
  <div class="controls">
    <h4>控制面板</h4>
    <button onclick="toggleLightHelpers()">切换灯光辅助器</button>
    <button onclick="adjustLights()">重新调整灯光</button>
    <button onclick="changeBuilding()">切换建筑尺寸</button>
    <button onclick="resetLights()">重置灯光</button>
  </div>

  <script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';
    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';

    // 全局变量
    let scene, camera, renderer, controls;
    let building, lights;
    let showLightHelpers = false;

    // 初始化场景
    function init () {
      // 创建场景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // 天空蓝

      // 创建相机
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(20, 15, 20);

      // 创建渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('container').appendChild(renderer.domElement);

      // 创建控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // 创建基础光源
      createBaseLights();

      // 创建测试建筑
      createTestBuilding();

      // 调整灯光位置
      adjustLightsToBuilding();

      // 创建地面
      createGround();

      console.log("场景初始化完成");
    }

    // 创建基础光源
    function createBaseLights () {
      // 环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
      scene.add(ambientLight);

      // 主方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.4);
      directionalLight.shadow.camera.near = 1;
      directionalLight.shadow.camera.far = 1000;
      directionalLight.shadow.camera.right = 1000;
      directionalLight.shadow.camera.left = -1000;
      directionalLight.shadow.camera.top = 600;
      directionalLight.shadow.camera.bottom = -600;
      directionalLight.shadow.mapSize.width = Math.pow(2, 11);
      directionalLight.shadow.mapSize.height = Math.pow(2, 11);
      directionalLight.shadow.blurSamples = 8;
      directionalLight.shadow.radius = 1.15;
      directionalLight.shadow.bias = -0.0015;
      directionalLight.castShadow = true;

      // 辅助方向光
      const auxiliaryLight = new THREE.DirectionalLight(0xffffff, 0.4);

      lights = {
        ambient: ambientLight,
        main: directionalLight,
        auxiliary: auxiliaryLight
      };

      scene.add(directionalLight);
      scene.add(auxiliaryLight);

      console.log("基础光源创建完成");
    }

    // 创建测试建筑
    function createTestBuilding () {
      // 创建建筑组
      building = new THREE.Group();

      // 创建建筑主体（立方体）
      const buildingGeometry = new THREE.BoxGeometry(8, 6, 10);
      const buildingMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xcccccc,
        metalness: 0.1,
        roughness: 0.8,
        envMapIntensity: 0.5
      });
      const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
      buildingMesh.castShadow = true;
      buildingMesh.receiveShadow = true;
      building.add(buildingMesh);

      // 创建屋顶
      const roofGeometry = new THREE.ConeGeometry(6, 2, 4);
      const roofMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x8B4513,
        metalness: 0.2,
        roughness: 0.7
      });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = 4;
      roof.castShadow = true;
      roof.receiveShadow = true;
      building.add(roof);

      // 创建窗户
      const windowGeometry = new THREE.PlaneGeometry(1, 1.5);
      const windowMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x87CEEB,
        metalness: 0.9,
        roughness: 0.1,
        transparent: true,
        opacity: 0.7
      });

      // 添加多个窗户
      const windowPositions = [
        { x: -3, y: 1, z: 5.1 },
        { x: 3, y: 1, z: 5.1 },
        { x: -3, y: 1, z: -5.1 },
        { x: 3, y: 1, z: -5.1 }
      ];

      windowPositions.forEach(pos => {
        const window = new THREE.Mesh(windowGeometry, windowMaterial);
        window.position.set(pos.x, pos.y, pos.z);
        window.castShadow = true;
        window.receiveShadow = true;
        building.add(window);
      });

      scene.add(building);
      updateBuildingInfo();
    }

    // 根据建筑包围盒调整灯光位置
    function adjustLightsToBuilding () {
      if (!building || !lights) {
        console.warn("建筑对象或灯光未初始化，无法调整灯光位置");
        return;
      }

      console.log("开始根据建筑包围盒调整灯光位置...");

      // 获取建筑包围盒
      const box = new THREE.Box3().setFromObject(building);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const min = box.min;
      const max = box.max;

      console.log("建筑包围盒信息:", {
        center: center,
        size: size,
        min: min,
        max: max
      });

      // 计算建筑尺寸
      const buildingWidth = size.x;
      const buildingHeight = size.y;
      const buildingDepth = size.z;
      const maxDimension = Math.max(buildingWidth, buildingHeight, buildingDepth);

      // 调整主方向光位置
      const mainLightDistance = maxDimension * 1.5;
      const mainLightHeight = center.y + buildingHeight * 0.8;
      const mainLightOffset = maxDimension * 0.8;

      // 主方向光位置：建筑中心上方，稍微偏移
      lights.main.position.set(
        center.x - mainLightOffset * 0.5,
        mainLightHeight,
        center.z - mainLightOffset * 0.8
      );

      // 调整主方向光的目标点（建筑中心）
      lights.main.target.position.copy(center);
      lights.main.target.updateMatrixWorld();

      // 调整主方向光的阴影相机参数
      const shadowSize = maxDimension * 2;
      lights.main.shadow.camera.left = -shadowSize;
      lights.main.shadow.camera.right = shadowSize;
      lights.main.shadow.camera.top = shadowSize;
      lights.main.shadow.camera.bottom = -shadowSize;
      lights.main.shadow.camera.near = 0.1;
      lights.main.shadow.camera.far = maxDimension * 4;
      lights.main.shadow.camera.updateProjectionMatrix();

      // 调整辅助方向光位置
      const auxiliaryLightDistance = maxDimension * 1.2;
      lights.auxiliary.position.set(
        center.x + auxiliaryLightDistance * 0.6,
        center.y + buildingHeight * 0.6,
        center.z + auxiliaryLightDistance * 0.4
      );

      // 调整辅助方向光的目标点
      lights.auxiliary.target.position.copy(center);
      lights.auxiliary.target.updateMatrixWorld();

      // 根据建筑尺寸调整灯光强度
      const buildingVolume = buildingWidth * buildingHeight * buildingDepth;
      const volumeFactor = Math.min(buildingVolume / 1000000, 2.0);

      lights.main.intensity = 1.4 * volumeFactor;
      lights.auxiliary.intensity = 0.4 * volumeFactor;
      lights.ambient.intensity = 1.5 * Math.min(volumeFactor, 1.5);

      console.log("灯光位置调整完成:", {
        mainLight: lights.main.position,
        auxiliaryLight: lights.auxiliary.position,
        mainIntensity: lights.main.intensity,
        auxiliaryIntensity: lights.auxiliary.intensity,
        ambientIntensity: lights.ambient.intensity
      });

      updateLightInfo();
    }

    // 创建地面
    function createGround () {
      const groundGeometry = new THREE.PlaneGeometry(50, 50);
      const groundMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x90EE90,
        metalness: 0.1,
        roughness: 0.8
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -3;
      ground.receiveShadow = true;
      scene.add(ground);
    }

    // 更新建筑信息显示
    function updateBuildingInfo () {
      if (!building) return;

      const box = new THREE.Box3().setFromObject(building);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      document.getElementById('buildingInfo').textContent =
        `尺寸: ${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`;
      document.getElementById('buildingBox').textContent =
        `中心: (${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)})`;
    }

    // 更新灯光信息显示
    function updateLightInfo () {
      if (!lights) return;

      document.getElementById('mainLightPos').textContent =
        `(${lights.main.position.x.toFixed(1)}, ${lights.main.position.y.toFixed(1)}, ${lights.main.position.z.toFixed(1)})`;
      document.getElementById('auxLightPos').textContent =
        `(${lights.auxiliary.position.x.toFixed(1)}, ${lights.auxiliary.position.y.toFixed(1)}, ${lights.auxiliary.position.z.toFixed(1)})`;
    }

    // 切换灯光辅助器
    function toggleLightHelpers () {
      showLightHelpers = !showLightHelpers;

      if (showLightHelpers) {
        addLightHelpers();
      } else {
        removeLightHelpers();
      }
    }

    // 添加灯光辅助器
    function addLightHelpers () {
      removeLightHelpers();

      // 主方向光辅助器
      window.mainLightHelper = new THREE.DirectionalLightHelper(lights.main, 5);
      scene.add(window.mainLightHelper);

      // 辅助方向光辅助器
      window.auxiliaryLightHelper = new THREE.DirectionalLightHelper(lights.auxiliary, 3);
      scene.add(window.auxiliaryLightHelper);

      // 阴影相机辅助器
      window.shadowCameraHelper = new THREE.CameraHelper(lights.main.shadow.camera);
      scene.add(window.shadowCameraHelper);

      console.log("灯光辅助器已添加");
    }

    // 移除灯光辅助器
    function removeLightHelpers () {
      if (window.mainLightHelper) {
        scene.remove(window.mainLightHelper);
        window.mainLightHelper.dispose();
        window.mainLightHelper = null;
      }

      if (window.auxiliaryLightHelper) {
        scene.remove(window.auxiliaryLightHelper);
        window.auxiliaryLightHelper.dispose();
        window.auxiliaryLightHelper = null;
      }

      if (window.shadowCameraHelper) {
        scene.remove(window.shadowCameraHelper);
        window.shadowCameraHelper.dispose();
        window.shadowCameraHelper = null;
      }
    }

    // 切换建筑尺寸
    function changeBuilding () {
      if (!building) return;

      // 随机调整建筑尺寸
      const scale = 0.5 + Math.random() * 1.5;
      building.scale.set(scale, scale, scale);

      // 重新调整灯光
      adjustLightsToBuilding();
      updateBuildingInfo();
    }

    // 重置灯光
    function resetLights () {
      if (!lights) return;

      lights.main.position.set(-100, 300, -300);
      lights.auxiliary.position.set(150, 100, 0);
      lights.main.intensity = 1.4;
      lights.auxiliary.intensity = 0.4;
      lights.ambient.intensity = 1.5;

      updateLightInfo();
    }

    // 暴露全局函数
    window.toggleLightHelpers = toggleLightHelpers;
    window.adjustLights = adjustLightsToBuilding;
    window.changeBuilding = changeBuilding;
    window.resetLights = resetLights;

    // 动画循环
    function animate () {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // 窗口大小调整
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 初始化
    init();
    animate();
  </script>
</body>

</html>
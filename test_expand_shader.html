<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>扩大着色器效果测试</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: white;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #2a2a2a;
      border-radius: 8px;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #45a049;
    }

    .info {
      background: #333;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .log {
      background: #000;
      padding: 15px;
      border-radius: 8px;
      height: 150px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }

    #canvas {
      width: 100%;
      height: 600px;
      border: 1px solid #444;
      border-radius: 8px;
    }

    .shader-info {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>扩大着色器效果测试</h1>

    <div class="info">
      <h3>测试说明：</h3>
      <p>1. 这个着色器基于扩大.glsl实现，创建动态的线网格效果</p>
      <p>2. 使用SDF（有向距离场）技术绘制网格线</p>
      <p>3. 包含动态的网格点动画和波浪效果</p>
    </div>

    <div class="shader-info">
      <h3>着色器特性：</h3>
      <ul>
        <li><strong>动态网格</strong>：基于时间的网格点动画</li>
        <li><strong>SDF线条</strong>：使用有向距离场绘制平滑线条</li>
        <li><strong>波浪效果</strong>：网格点带有波浪运动</li>
        <li><strong>颜色偏移</strong>：RGB通道分离产生彩色效果</li>
        <li><strong>伽马校正</strong>：正确的颜色空间处理</li>
      </ul>
    </div>

    <div class="controls">
      <h3>控制选项：</h3>
      <button onclick="toggleAnimation()">暂停/继续动画</button>
      <button onclick="resetAnimation()">重置动画</button>
      <button onclick="toggleWireframe()">切换线框模式</button>
    </div>

    <div class="log" id="log"></div>

    <canvas id="canvas"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    // 全局变量
    let scene, camera, renderer, controls;
    let ground = null;
    let animationPaused = false;
    let elapsedTime = 0;

    // 日志函数
    function log (message) {
      const logElement = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString();
      logElement.innerHTML += `[${timestamp}] ${message}<br>`;
      logElement.scrollTop = logElement.scrollHeight;
      console.log(message);
    }

    // 初始化场景
    function init () {
      // 创建场景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      // 创建相机
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(50, 50, 50);

      // 创建渲染器
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // 创建控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // 添加环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      // 添加方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // 创建地面
      createGround();

      log('场景初始化完成');
    }

    // 创建地面
    function createGround () {
      const groundWidth = 100;
      const groundHeight = 100;

      const geometry = new THREE.PlaneGeometry(groundWidth, groundHeight);
      geometry.rotateX(-Math.PI / 2);

      const material = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        transparent: true,
        uniforms: {
          uTime: { value: 0.0 },
          uResolution: { value: new THREE.Vector2(groundWidth, groundHeight) },
          uFrame: { value: 0 },
        },
        vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
        fragmentShader: `
                    #define tau 6.28
                    
                    uniform float uTime;
                    uniform vec2 uResolution;
                    uniform int uFrame;
                    
                    varying vec2 vUv;
                    
                    float scl = 15.0;
                    
                    mat2 rotate(float rad) {
                        float c = cos(rad);
                        float s = sin(rad);
                        return mat2(c, -s, s, c);
                    }
                    
                    // cubic pulse by iq
                    float cubicPulse(float c, float w, float x) {
                        x = abs(x - c);
                        if(x > w) return 0.0;
                        x /= w;
                        return 1.0 - x * x * (3.0 - 2.0 * x);
                    }
                    
                    // 2D sdf by iq
                    float sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {
                        float l = length(b - a);
                        vec2 d = (b - a) / l;
                        vec2 q = (p - (a + b) * 0.5);
                        q = mat2(d.x, -d.y, d.y, d.x) * q;
                        q = abs(q) - vec2(l, th) * 0.5;
                        return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
                    }
                    
                    float sdRoundedLine(in vec2 p, in vec2 a, in vec2 b, float weight, float roundedness) {
                        return sdOrientedBox(p, a, b, weight) - roundedness;
                    }
                    
                    float sdGridLine(vec2 cellPos, vec2 a, vec2 b) {
                        float lineLength = distance(a, b);
                        float line = sdOrientedBox(cellPos, a, b, 0.0);
                        float smallLength = 0.0;
                        float bigLength = 1.5;
                        float closeness = smoothstep(bigLength, smallLength, lineLength);
                        float thickness = 0.05;
                        return closeness * smoothstep(thickness, 0.0, line);
                    }
                    
                    // Hash without Sine - David Hoskins
                    float hash12(vec2 p) {
                        vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                        p3 += dot(p3, p3.yzx + 33.33);
                        return fract((p3.x + p3.y) * p3.z);
                    }
                    
                    vec2 getGridPoint(vec2 id) {
                        float t = float(uFrame) * 0.001;
                        float d = smoothstep(scl * 0.33, 0.0, length(id));
                        float theta = tau * (t + 731.154 * hash12(id));
                        float x = d * 0.4 * cos(theta);
                        float y = d * 0.4 * sin(theta);
                        vec2 wave = (1.0 - d) * 0.03 * id * sin(length(id) - t * scl * 0.66);
                        return vec2(x, y) + wave;
                    }
                    
                    float allLinesOnThisCell(vec2 cellPos, vec2[9] points) {
                        float sum = 0.0;
                        sum += sdGridLine(cellPos, points[4], points[0]);
                        sum += sdGridLine(cellPos, points[4], points[1]);
                        sum += sdGridLine(cellPos, points[4], points[2]);
                        sum += sdGridLine(cellPos, points[4], points[3]);
                        sum += sdGridLine(cellPos, points[4], points[5]);
                        sum += sdGridLine(cellPos, points[4], points[6]);
                        sum += sdGridLine(cellPos, points[4], points[7]);
                        sum += sdGridLine(cellPos, points[4], points[8]);
                        sum += sdGridLine(cellPos, points[1], points[3]);
                        sum += sdGridLine(cellPos, points[1], points[5]);
                        sum += sdGridLine(cellPos, points[3], points[7]);
                        sum += sdGridLine(cellPos, points[5], points[7]);
                        return sum;
                    }
                    
                    vec2[9] createPointMatrix(vec2 cellId) {
                        vec2[9] pointMatrix;
                        float range = 1.0;
                        int i = 0;
                        for(float x = -range; x <= range; x++) {
                            for(float y = -range; y <= range; y++) {
                                vec2 offset = vec2(x, y);
                                pointMatrix[i] = getGridPoint(cellId + offset) + offset;
                                i++;
                            }
                        }
                        return pointMatrix;
                    }
                    
                    float render(vec2 uv) {
                        float pct = 0.12;
                        vec2 cellPos = fract(uv * scl) - 0.5;
                        vec2 cellId = floor(uv * scl) + 0.5;
                        vec2[9] pointMatrix = createPointMatrix(cellId);
                        return allLinesOnThisCell(cellPos, pointMatrix);
                    }
                    
                    vec3 gammaCorrection(vec3 rgb) {
                        float gamma = 2.2;
                        return pow(max(rgb, 0.0), vec3(1.0 / gamma));
                    }
                    
                    void main() {
                        vec2 uv = (vUv - 0.5) * 2.0;
                        uv.x *= uResolution.x / uResolution.y;
                        
                        vec2 colorOffset = normalize(uv) * 0.003 * smoothstep(0.2, 0.5, length(uv));
                        vec3 col = vec3(
                            render(uv - colorOffset),
                            render(uv),
                            render(uv + colorOffset)
                        );
                        
                        // 添加边缘抗锯齿
                        float edge = smoothstep(0.0, 0.1, 1.0 - length(vUv - 0.5) * 2.0);
                        col *= edge;
                        
                        gl_FragColor = vec4(gammaCorrection(col), 0.6);
                    }
                `,
      });

      ground = new THREE.Mesh(geometry, material);
      ground.position.set(0, -1, 0);
      ground.receiveShadow = true;

      scene.add(ground);
      log('地面着色器创建完成');
    }

    // 切换动画
    function toggleAnimation () {
      animationPaused = !animationPaused;
      log(`动画${animationPaused ? '已暂停' : '已继续'}`);
    }

    // 重置动画
    function resetAnimation () {
      elapsedTime = 0;
      log('动画已重置');
    }

    // 切换线框模式
    function toggleWireframe () {
      if (ground && ground.material) {
        ground.material.wireframe = !ground.material.wireframe;
        log(`线框模式${ground.material.wireframe ? '已开启' : '已关闭'}`);
      }
    }

    // 动画循环
    function animate () {
      requestAnimationFrame(animate);

      if (!animationPaused) {
        elapsedTime += 0.016; // 假设60fps

        // 更新着色器uniforms
        if (ground && ground.material.uniforms) {
          ground.material.uniforms.uTime.value = elapsedTime;
          ground.material.uniforms.uFrame.value = Math.floor(elapsedTime * 60);
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // 窗口大小调整
    function onWindowResize () {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    }

    // 暴露给全局
    window.toggleAnimation = toggleAnimation;
    window.resetAnimation = resetAnimation;
    window.toggleWireframe = toggleWireframe;

    // 初始化
    init();
    animate();
    window.addEventListener('resize', onWindowResize);
  </script>
</body>

</html>
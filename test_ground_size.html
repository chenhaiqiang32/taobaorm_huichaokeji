<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>地面尺寸测试</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
    }

    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    button {
      margin: 5px;
      padding: 5px 10px;
      background: #333;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    button:hover {
      background: #555;
    }
  </style>
</head>

<body>
  <div class="info">
    <h3>地面尺寸测试</h3>
    <p>当前地面尺寸: <span id="groundSize">计算中...</span></p>
    <p>模型包围盒: <span id="modelBox">无</span></p>
    <p>地面位置: <span id="groundPosition">计算中...</span></p>
  </div>

  <div class="controls">
    <h4>测试选项</h4>
    <button onclick="testWithBoundingBox()">测试有包围盒</button>
    <button onclick="testWithoutBoundingBox()">测试无包围盒</button>
    <button onclick="testLargeModel()">测试大模型</button>
    <button onclick="testSmallModel()">测试小模型</button>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // 创建场景
    const scene = new THREE.Scene();

    // 创建相机
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 50, 100);
    camera.lookAt(0, 0, 0);

    // 创建渲染器
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    // 添加环境光
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);

    // 添加方向光
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    scene.add(directionalLight);

    // 创建时钟
    const clock = new THREE.Clock();

    // 模拟核心对象
    const mockCore = {
      elapsedTime: 0
    };

    let currentGround = null;
    let currentModel = null;

    // 模拟 SpecialGround 类
    class SpecialGround extends THREE.Mesh {
      constructor(center, min, boundingBox = null) {
        super();

        // 计算地面尺寸
        let groundWidth, groundHeight;

        if (boundingBox) {
          // 如果有包围盒，使用包围盒尺寸并增加一些边距
          const boxSize = new THREE.Vector3();
          boundingBox.getSize(boxSize);
          const padding = Math.max(boxSize.x, boxSize.z) * 0.2; // 20% 的边距
          groundWidth = boxSize.x + padding;
          groundHeight = boxSize.z + padding;
        } else {
          // 如果没有包围盒，使用默认尺寸（比原来小很多）
          groundWidth = 100;
          groundHeight = 100;
        }

        // 设置地面位置在包围盒的 min 位置
        this.position.set(min.x, min.y - 20, min.z);
        this.geometry = new THREE.PlaneGeometry(groundWidth, groundHeight);
        this.geometry.rotateX(-Math.PI / 2);

        // 更新显示信息
        updateInfo(groundWidth, groundHeight, boundingBox, this.position);

        // 使用简单的材质用于测试
        this.material = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.5,
          wireframe: true
        });
      }

      update (core) {
        // 更新时间uniform（如果有的话）
        if (this.material && this.material.uniforms) {
          this.material.uniforms.uTime.value = core.elapsedTime;
        }
      }
    }

    function updateInfo (width, height, boundingBox, position) {
      document.getElementById('groundSize').textContent = `${width.toFixed(1)} x ${height.toFixed(1)}`;
      document.getElementById('groundPosition').textContent = `(${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)})`;

      if (boundingBox) {
        const size = new THREE.Vector3();
        boundingBox.getSize(size);
        document.getElementById('modelBox').textContent = `${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`;
      } else {
        document.getElementById('modelBox').textContent = '无';
      }
    }

    function createTestModel (size = 10) {
      // 移除现有模型
      if (currentModel) {
        scene.remove(currentModel);
      }

      // 创建测试模型（立方体）
      const geometry = new THREE.BoxGeometry(size, size, size);
      const material = new THREE.MeshLambertMaterial({ color: 0xff0000 });
      currentModel = new THREE.Mesh(geometry, material);
      scene.add(currentModel);

      return currentModel;
    }

    function createGround (center, min, boundingBox = null) {
      // 移除现有地面
      if (currentGround) {
        scene.remove(currentGround);
      }

      // 创建新地面
      currentGround = new SpecialGround(center, min, boundingBox);
      scene.add(currentGround);

      return currentGround;
    }

    // 测试函数
    window.testWithBoundingBox = function () {
      const model = createTestModel(20);
      const boundingBox = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      const min = boundingBox.min;

      createGround(center, min, boundingBox);
    };

    window.testWithoutBoundingBox = function () {
      const center = new THREE.Vector3(0, 0, 0);
      const min = new THREE.Vector3(-10, -10, -10);

      createGround(center, min, null);
    };

    window.testLargeModel = function () {
      const model = createTestModel(50);
      const boundingBox = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      const min = boundingBox.min;

      createGround(center, min, boundingBox);
    };

    window.testSmallModel = function () {
      const model = createTestModel(5);
      const boundingBox = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3();
      boundingBox.getCenter(center);
      const min = boundingBox.min;

      createGround(center, min, boundingBox);
    };

    // 初始化测试
    testWithBoundingBox();

    // 动画循环
    function animate () {
      requestAnimationFrame(animate);

      // 更新时间
      mockCore.elapsedTime = clock.getElapsedTime();

      // 更新地面着色器
      if (currentGround && currentGround.update) {
        currentGround.update(mockCore);
      }

      // 渲染场景
      renderer.render(scene, camera);
    }

    // 开始动画
    animate();

    // 窗口大小调整
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
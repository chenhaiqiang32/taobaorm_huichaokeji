<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>地面重新计算测试</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: white;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #2a2a2a;
      border-radius: 8px;
    }

    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #45a049;
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
    }

    .info {
      background: #333;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .log {
      background: #000;
      padding: 15px;
      border-radius: 8px;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }

    #canvas {
      width: 100%;
      height: 600px;
      border: 1px solid #444;
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>地面重新计算测试</h1>

    <div class="info">
      <h3>测试说明：</h3>
      <p>1. 点击不同的模型按钮加载不同的室内模型</p>
      <p>2. 观察控制台日志，确认每次加载新模型时地面都会重新计算</p>
      <p>3. 地面尺寸会根据新模型的包围盒自动调整</p>
    </div>

    <div class="controls">
      <h3>模型选择：</h3>
      <button onclick="loadModel('AFS9512042_制冷')">加载制冷模型</button>
      <button onclick="loadModel('AFS9512043_制热')">加载制热模型</button>
      <button onclick="loadModel('AFS9512044_配电室')">加载配电室模型</button>
      <button onclick="clearScene()">清空场景</button>
    </div>

    <div class="log" id="log"></div>

    <canvas id="canvas"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';

    // 全局变量
    let scene, camera, renderer, controls;
    let currentBuilding = null;
    let currentGround = null;

    // 日志函数
    function log (message) {
      const logElement = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString();
      logElement.innerHTML += `[${timestamp}] ${message}<br>`;
      logElement.scrollTop = logElement.scrollHeight;
      console.log(message);
    }

    // 初始化场景
    function init () {
      // 创建场景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);

      // 创建相机
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(50, 50, 50);

      // 创建渲染器
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // 创建控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // 添加环境光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      // 添加方向光
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      log('场景初始化完成');
    }

    // 获取包围盒中心点
    function getBoxCenter (object) {
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const radius = Math.max(size.x, size.y, size.z) / 2;
      return { center, size, radius, min: box.min, max: box.max };
    }

    // 创建地面着色器材质
    function createGroundShaderMaterial () {
      const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

      const fragmentShader = `
                uniform float uTime;
                varying vec2 vUv;
                
                #define PI 3.14159265359
                #define TARGET_COUNT 15
                #define GRID_CELL_SIZE 0.1
                #define RED vec3(1.0, 0.0, 0.0)
                #define GREEN vec3(0.0, 1.0, 0.0)
                #define BLUE vec3(0.051, 0.7294, 0.698)
                
                vec2 getGridPosition(in vec2 uv) {
                    return vec2((uv.x/GRID_CELL_SIZE), (uv.y/GRID_CELL_SIZE));
                }
                
                void main() {
                    vec2 uv = vUv;
                    
                    // 添加小偏移以减少采样伪影
                    uv += vec2(0.001, 0.001);
                    
                    vec2 gridBoundUV = getGridPosition(uv);
                    vec2 cellBoundUV = gridBoundUV - round(gridBoundUV);
                    
                    float redIntensity = 0.0;
                    float blueIntensity = 0.0;
                    
                    for(int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex) {
                        float f_targetIndex = float(targetIndex);
                        
                        float trigOffset = (PI/float(TARGET_COUNT)) * f_targetIndex;
                        vec2 targetPosition = vec2(
                            sin(uTime + trigOffset) * 0.51 + tan(f_targetIndex + trigOffset),
                            cos(uTime + trigOffset) * 0.1 + sin(f_targetIndex + trigOffset)
                        );
                        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);
                        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);
                        
                        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) + 
                                               length((gridBoundUV) - (edgeBoundPosition));
                        
                        redIntensity += length(GRID_CELL_SIZE / (distanceToTarget * 9.5) / cellBoundUV) * GRID_CELL_SIZE;
                    }
                    
                    for(int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex) {
                        float f_targetIndex = float(targetIndex);
                        
                        float trigOffset = (PI/float(TARGET_COUNT)) * f_targetIndex;
                        
                        vec2 targetPosition = vec2(
                            sin(uTime + trigOffset) * 0.51 + sin(f_targetIndex + trigOffset),
                            tan(uTime + trigOffset) * 0.1 + sin(f_targetIndex + trigOffset)
                        );
                        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);
                        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);
                        
                        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) + 
                                               distance(gridBoundUV, edgeBoundPosition);
                        
                        blueIntensity += length(GRID_CELL_SIZE / (distanceToTarget * 15.5) / cellBoundUV) * GRID_CELL_SIZE;
                    }
                    
                    vec3 col = vec3(smoothstep(0.2, 1.0, redIntensity + blueIntensity));
                    
                    col += redIntensity * GREEN;
                    col += blueIntensity * BLUE;
                    
                    // 边缘抗锯齿
                    float edge = smoothstep(0.0, 0.1, uv.x) * smoothstep(1.0, 0.9, uv.x) * 
                                smoothstep(0.0, 0.1, uv.y) * smoothstep(1.0, 0.9, uv.y);
                    col *= edge;
                    
                    gl_FragColor = vec4(col, 0.4);
                }
            `;

      return new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uTime: { value: 0 }
        },
        transparent: true,
        side: THREE.DoubleSide
      });
    }

    // 创建地面
    function createGround (boundingBox) {
      // 移除现有地面
      if (currentGround) {
        scene.remove(currentGround);
        if (currentGround.geometry) {
          currentGround.geometry.dispose();
        }
        if (currentGround.material) {
          currentGround.material.dispose();
        }
      }

      if (!boundingBox) {
        log('警告：没有提供包围盒，使用默认地面尺寸');
        boundingBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(100, 1, 100)
        );
      }

      // 计算地面尺寸（包围盒的20%边距）
      const size = boundingBox.getSize(new THREE.Vector3());
      const groundWidth = size.x * 1.2;
      const groundDepth = size.z * 1.2;

      // 计算地面位置（包围盒中心，稍微降低Y坐标）
      const center = boundingBox.getCenter(new THREE.Vector3());
      const groundY = boundingBox.min.y - 1;

      // 创建地面几何体
      const geometry = new THREE.PlaneGeometry(groundWidth, groundDepth);
      const material = createGroundShaderMaterial();

      currentGround = new THREE.Mesh(geometry, material);
      currentGround.rotation.x = -Math.PI / 2; // 水平放置
      currentGround.position.set(center.x, groundY, center.z);
      currentGround.receiveShadow = true;

      scene.add(currentGround);

      log(`地面已创建 - 尺寸: ${groundWidth.toFixed(1)} x ${groundDepth.toFixed(1)}, 位置: (${center.x.toFixed(1)}, ${groundY.toFixed(1)}, ${center.z.toFixed(1)})`);

      return currentGround;
    }

    // 加载模型
    async function loadModel (modelName) {
      log(`开始加载模型: ${modelName}`);

      // 清理现有模型
      if (currentBuilding) {
        scene.remove(currentBuilding);
        currentBuilding = null;
      }

      try {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync(`./models/inDoor/${modelName}.glb`);

        const building = gltf.scene;
        const group = building.children.find(child => child.name === "equip");

        if (!group) {
          throw new Error('未找到equip组');
        }

        // 处理模型材质
        group.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material = child.material.clone();
            child.material.transparent = true;
            child.material.metalness = 0.2;
            child.material.roughness = 0.8;
          }
        });

        scene.add(building);
        currentBuilding = group;

        // 获取包围盒并创建地面
        const boundingBox = new THREE.Box3().setFromObject(group);
        createGround(boundingBox);

        // 调整相机位置
        const { center, radius } = getBoxCenter(group);
        const distance = radius * 3;
        camera.position.set(center.x + distance, center.y + distance, center.z + distance);
        controls.target.copy(center);
        controls.update();

        log(`模型加载完成: ${modelName}`);
        log(`模型包围盒: 最小(${boundingBox.min.x.toFixed(1)}, ${boundingBox.min.y.toFixed(1)}, ${boundingBox.min.z.toFixed(1)}) 最大(${boundingBox.max.x.toFixed(1)}, ${boundingBox.max.y.toFixed(1)}, ${boundingBox.max.z.toFixed(1)})`);

      } catch (error) {
        log(`模型加载失败: ${error.message}`);
        console.error('加载模型时出错:', error);
      }
    }

    // 清空场景
    function clearScene () {
      if (currentBuilding) {
        scene.remove(currentBuilding);
        currentBuilding = null;
      }
      if (currentGround) {
        scene.remove(currentGround);
        if (currentGround.geometry) {
          currentGround.geometry.dispose();
        }
        if (currentGround.material) {
          currentGround.material.dispose();
        }
        currentGround = null;
      }
      log('场景已清空');
    }

    // 动画循环
    function animate () {
      requestAnimationFrame(animate);

      // 更新地面着色器时间
      if (currentGround && currentGround.material.uniforms) {
        currentGround.material.uniforms.uTime.value += 0.01;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    // 窗口大小调整
    function onWindowResize () {
      const canvas = document.getElementById('canvas');
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    }

    // 暴露给全局
    window.loadModel = loadModel;
    window.clearScene = clearScene;

    // 初始化
    init();
    animate();
    window.addEventListener('resize', onWindowResize);
  </script>
</body>

</html>